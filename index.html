<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Annika Hirsch">

<title>Have I gotten faster?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Have I gotten faster?</h1>
<p class="subtitle lead">An analysis of Mountainbiking Data</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Annika Hirsch </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>While Mountainbiking I often repeat the same trails. Since I hope my technique has improved over the years, I wonder if that is also represented in the characteristics of the rides. Have I gotten faster, smoother, need less rests? For comparability I only analyse data from one specific trail. I have calculated the speed, acceleration and jerk for the different recordings and shorter segments thereof. This data is then additionally visualised in an animated graphic of the different recordings.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In the six years that I have now gone mountainbiking frequently in my spare time, I have tracked almost every ride with GPS. This has created a lot of data. Part of which I now want to analyse. Specifically the data from one of my favourite trails: “Bleiki DH” in the “Bleikiwald” on the mountain “Harder” in Interlaken, Switzerland. I hope that my riding has improved over the years. But how much or how exactly is that represented in the GPS data?</p>
<p>The app that I use most of the time to track my activities is Strava. Strava has specific features that allow to measure the times in defined segments (either created by oneself or created by other users) these times can then be compared to other users and a ranking is generated. Therefore I know that my time on this trail, “Bleiki DH”, has improved during the years. I also know that I can now ride more sections of the trail, compared to the beginning, where I had to walk some sections. So I can assume that my overall speed has gotten faster, but how exactly is this displayed in the data? Am I riding faster, smoother or am I just needing less rests? This is what I aim to find out in this project.</p>
<p>The research question for this project is therefore: Do the characteristics - speed, acceleration and jerk - differ between my different activity records?</p>
<p>Mountainbiking GPS activity data has been used in multiple studies to monitor and manage trail systems (Mendes et al., 2023; Wolf et al., 2015). But there are few papers that analyse the performance of mountainbikers using GPS data. Hurst et al.&nbsp;(2013) have studied the influence of different course types on the activity profiles based on GPS data. Apart from that I could not find anything related to mountainbiking and using GPS-data to assess the performance of riders.</p>
</section>
<section id="material-and-methods" class="level2">
<h2 class="anchored" data-anchor-id="material-and-methods">Material and Methods</h2>
<section id="material" class="level3">
<h3 class="anchored" data-anchor-id="material">Material</h3>
<p>To answer my question I used Mountainbiking activity records. These activity records all have in common, that I ride the same specific segment: “Bleiki DH”. This is an established Strava Segment on a hiking path through the “Bleikiwald” on the “Harder” in Interlaken. All activity records used in this analysis are recorded with Strava. There are thirteen in total:</p>
<ol type="1">
<li>a1: “kurz_auf_den_harder”, 26.04.2023</li>
<li>a2: “2_Anlauf_Bleiki_DH_Sturz_”, 29.06.2020</li>
<li>a3: “2x_Harder_”, 23.07.2022</li>
<li>a4: “Bleiki_”, 21.08.2022</li>
<li>a5: “Bleiki_aber_diesmal_trocken”, 03.05.2021</li>
<li>a6: “Bleiki_DH”, 26.06.2020</li>
<li>a7: “Bleiki_Liebe_”, 11.10.2022</li>
<li>a8: “Einmal_schnell_zum_einkaufen”, 15.08.2021</li>
<li>a9: “Erholunsfahrt”, 02.08.2022</li>
<li>a10: “Harder_”, 04.05.2023</li>
<li>a11: “Hike_a_Bike_auf_den_harder”, 18.04.2023</li>
<li>a12: “Rutschige_nasse_Bleiki”, 01.05.2021</li>
<li>a13: “Sturz_Platten_und_kein_GPS”, 02.08.2021</li>
</ol>
<p>The titles shown in the list above are the original titel, that I gave the named the activity after finishing the ride. Judging from the titles, the trail has different conditions (“diesmal trocken”, “Rutschige nasse”), I had falls (“Sturz”) or problems with the GPS (“kein GPS”). The activities were tracked with different devices (old phone, new phone, watch) but I do not remember which activity was tracked with which device and this is therefore ignored.</p>
<p>To crop the records to the correct extent (“Bleiki DH”), I used a manually drawn line of the part of the hiking path on the Swisstopo Web Map. To attempt the Map Matching, I started with using the “DKM10_STRASSE” layer from the vectorized 1:10 000 map from Swisstopo (https://www.swisstopo.admin.ch/de/landeskarte-swiss-map-vector-10). Since this path does not match the real course of the hiking path, I later used the path from the Open Street Map (https://www.openstreetmap.org/#map=16/46.6937/7.8627), which does match the Digital Elevation Model better.</p>
</section>
<section id="methods" class="level3">
<h3 class="anchored" data-anchor-id="methods">Methods</h3>
<p>The activity records are full mountainbike rides, so they include not only the data of the trail, but also the ascent or potential additional trails. These parts had to be eliminated and it had to be made sure that only the relevant parts of the activity, the segment “Bleiki DH”, remained. To do that, I drew by hand a line on the Webmap of Swisstopo (https://map.geo.admin.ch) of the trail and exported that. I then created a buffer of 20 meter around it and deleted all GPS fixes that were outside of this zone. Since the climb to the start of this segment does cross the segment regularly these points were also included. To achieve that the fixes were divided into segments according to the timestamp and only the longest segment was kept.</p>
<p>Then I continued with calculating the speed in three different ways. The first one is the simple calculation of the speed between two consecutive fixes by calculating the distance from the coordinates and dividing that through the time difference. The second and third ways are analog to the method used by Laube and Purves (2011) and similar to the way it was done in the course. This was done for 5 consecutive fixes and 11 consecutive fixes. Afterwards I filtered out static points, here speeds slower than 1 m/s.</p>
<p>To analyse the smoothness, I calculated acceleration and jerk of the recordings. I then calculated the mean and the standard deviation for all three metrics. As well as the time in between the first and the last point.</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>The table “summary metrics” shows the total time, the mean and the standard deviation of the speed, acceleration and jerk always calculated for two consecutive fixes and with the static points filtered out. The four times, which are around four minutes are not possible and some points must have been deleted during an additional cropping to filter out the points that are rests at the end of the segment.</p>
<table class="table-striped table-hover table">
<caption>Summary Metrics</caption>
<colgroup>
<col style="width: 12%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 8%">
<col style="width: 18%">
<col style="width: 16%">
<col style="width: 12%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th>name</th>
<th>total_time</th>
<th>mean_speed</th>
<th>sd_speed</th>
<th>mean_acceleration</th>
<th>sd_acceleration</th>
<th>mean_jerk</th>
<th>sd_jerk</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a1</td>
<td>8.733333</td>
<td>3.550957</td>
<td>1.868654</td>
<td>-0.14128463</td>
<td>1.4838684</td>
<td>-0.24563120</td>
<td>2.014201</td>
</tr>
<tr class="even">
<td>a2</td>
<td>8.200000</td>
<td>2.381524</td>
<td>1.420432</td>
<td>-0.13212074</td>
<td>1.1349399</td>
<td>-0.17480290</td>
<td>1.532881</td>
</tr>
<tr class="odd">
<td>a3</td>
<td>9.216667</td>
<td>3.202388</td>
<td>1.764958</td>
<td>-0.13992214</td>
<td>1.4473926</td>
<td>-0.20882592</td>
<td>2.054420</td>
</tr>
<tr class="even">
<td>a4</td>
<td>3.916667</td>
<td>2.214098</td>
<td>1.073469</td>
<td>-0.02486591</td>
<td>0.9402657</td>
<td>-0.01139307</td>
<td>1.355023</td>
</tr>
<tr class="odd">
<td>a5</td>
<td>12.200000</td>
<td>2.809733</td>
<td>3.427974</td>
<td>-0.29801549</td>
<td>2.5890709</td>
<td>-0.19355522</td>
<td>3.432843</td>
</tr>
<tr class="even">
<td>a6</td>
<td>9.050000</td>
<td>2.585993</td>
<td>2.430425</td>
<td>-0.11758939</td>
<td>1.8874779</td>
<td>-0.19564350</td>
<td>2.863061</td>
</tr>
<tr class="odd">
<td>a7</td>
<td>8.816667</td>
<td>3.324868</td>
<td>1.687150</td>
<td>-0.10434437</td>
<td>1.4729562</td>
<td>-0.18114721</td>
<td>2.147620</td>
</tr>
<tr class="even">
<td>a8</td>
<td>9.400000</td>
<td>3.670464</td>
<td>2.052802</td>
<td>-0.19795605</td>
<td>1.6906365</td>
<td>-0.28175639</td>
<td>2.299059</td>
</tr>
<tr class="odd">
<td>a9</td>
<td>9.083333</td>
<td>3.368626</td>
<td>1.579005</td>
<td>-0.12241071</td>
<td>1.3404117</td>
<td>-0.20462191</td>
<td>1.918729</td>
</tr>
<tr class="even">
<td>a10</td>
<td>4.166667</td>
<td>3.947066</td>
<td>1.961292</td>
<td>-0.17986730</td>
<td>1.6270238</td>
<td>-0.23457723</td>
<td>2.290749</td>
</tr>
<tr class="odd">
<td>a11</td>
<td>9.166667</td>
<td>3.443760</td>
<td>1.811001</td>
<td>-0.16247303</td>
<td>1.6066817</td>
<td>-0.24477666</td>
<td>2.265705</td>
</tr>
<tr class="even">
<td>a12</td>
<td>3.150000</td>
<td>2.397451</td>
<td>1.675945</td>
<td>-0.17855052</td>
<td>1.1438687</td>
<td>-0.17781120</td>
<td>1.559298</td>
</tr>
<tr class="odd">
<td>a13</td>
<td>4.016667</td>
<td>2.745504</td>
<td>2.304157</td>
<td>-0.22935451</td>
<td>1.4734592</td>
<td>-0.16390741</td>
<td>2.146192</td>
</tr>
</tbody>
</table>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>Many parts of this project turned out to be more challenging, than expected. While the calculation of the metrics is not difficult in itself, the difficulty for me was to crop the data to the correct extents, spatially and temporally, and to deal with inaccuracies of the GPS positions. Animating the data was also challenging because of the computation times. These problems resulted in a serious delay.</p>
<p>The analysis in this project was carried out on the original GPS fixes of the activity recordings and not a map matched version of the GPS points, even though the trail that I rode was clear and it was always the same. Mapmatching would have ensured, that the ridden distances also stay the same. By using the original position these differ slightly. But the mapmatched positions could not be used, because of the inaccuracy of the GPS fixes of my records. Often, the GPS fixes were offset by a few meters. This is not of consequence in a large scale and the position was not far off. But especially in corners or tight switchbacks it was a serious issue. When mapmatching, the fixes would get matched to the wrong part of the turn. This lead to a mixup of the order of the fixes, and a calculation of speed would have resulted in fast speeds followed by negative speeds. This issue could have been solved by altering the mapmatching script, to incorporate the timestamp and making sure that the order must be kept. This would then in turn have meant, that possible backwards movements (like falling and having to go back to pickup the bike or checking out lines and then going back to approach them) would have been missed. Another minor problem that I encountered in my attempt of mapmatching the GPS fixes was that the trail on the Swisstopo map did not match the real location of the trail. That was easily remedied by using the trail from Open Street Map data. When displaying the Swisstopo Trail on the Digital Elevation Model (DEM) it was apparent that the Trail, as drawn on Swisstopo does not match the real location of the trail. Whereas the trail from the Open Street map does match the DEM. The use of mapmatched fixes for the analysis would have been more important, if I tried to correlate the results of the analysis to, for example, a DEM, because the few meters that the GPS fixes are of would have mattered more.</p>
<p>I stored the recordings for each activity in individual dataframes. Therefore I have to execute all steps of the processing for every dataframe. This leads to a lots of repeated lines of code with only changing the name of the dataframe. Unfortunately I could not find out how to do this more efficiently, while keeping the data structured as it is. This consequently also meant, that I wrote functions for almost every calculation, that could not be carried out in a single line of code. If I would revise the script, I could adapt it to contain less functions, but functions that do more. Since the functions were developed as I went along and then directly applied to all dataframes, the code is the way it is.</p>
<p>Additionally to the 13 Strava records that were used to do the analysis, I also have three recordings with Komoot that were recorded prior to the Strava records. At this time, I used both apps for different purposes: I tried to ride fast in the Strava segments that mattered to me (usually descents and not ascents) when recording with Strava and did not care about the speed in specific segments when recording with Komoot (only the average speed of the whole activity mattered to me). Back then I mostly used Komoot as my default tracking app, whereas I now use Strava as my default. Using Strava had a specific purpose and now using Komoot has the opposite specific purpose for me. The Komoot records were not analysed here due to time constraints, and I focused on the Strava records since I had more of them. Therefore a possible topic of Research to continue this analysis would be, if there is a significant difference in the characteristics of the activity when tracking with different apps. Are different activity tracking apps used for different purposes?</p>
</section>
<section id="appendix" class="level2">
<h2 class="anchored" data-anchor-id="appendix">Appendix</h2>
<section id="wordcount" class="level3">
<h3 class="anchored" data-anchor-id="wordcount">Wordcount</h3>
<!-- after installing the wordcountadding, remove the line "#| eval: false" -->
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>wordcountaddin<span class="sc">::</span><span class="fu">word_count</span>(<span class="st">"index.qmd"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>wordcountaddin<span class="sc">::</span><span class="fu">text_stats</span>(<span class="st">"index.qmd"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>